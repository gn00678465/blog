---
title: 函式 function
date: 2019-12-16 10:52:14
categories:
- JavaScript
tags:
- Basic
- JavaScript
---
# 什麼是函式
{% asset_img function_1.png 800 %}
「函式」指的是將一或多段程式指令包裝起來，可以重複使用，也方便維護。
**函式是物件的一種**

一個函式會有以下特性：
- 函式是可被呼叫的。
- 函式的名稱 (也可能沒有名稱)。
- 在括號 `( )` 中的部分，稱為「參數 (arguments) 」，參數與參數之間會用逗號 `,` 隔開。
- 在大括號 `{ }` 內的部分，內含需要**重複執行的內容**，是函式功能的主要區塊。

宣告函式的方法
- 具名函式
使用 `function 名稱(參數) { ... };` 的方式
```javascript
function functionA() {
  console.log('具名函式', '函式陳述式');
  console.log(functionA)
}
functionA()
```
{% note no-icon %}
ƒ functionA() {
  console.log('具名函式', '函式陳述式');
  console.log(functionA)
}
{% endnote %}
- 匿名函式
  透過 `變數名稱 = function(參數){ ... };` 的方式，將一個函式透過 `=` 指定給某個變數。
  ```javascript
  var functionB = function () {
    console.log('匿名函式', '函式表達式');
    console.log(functionB)
  }
  functionB()
  ```
  {% note no-icon %}
  ƒ () {
    console.log('匿名函式', '函式表達式');
    console.log(functionB)
  }
  {% endnote %}
  在匿名函式中，如果想要在 function 後面加上一個名字也是可以的，但是要注意的是，這個名字只在「<font color="red">自己函式的區塊內</font>」有效。
  脫離了函式自身區塊後，變數 `functionD` 就不存在了。
  ```javascript
  var functionC = function functionD() {
    console.log(functionC, functionD)
    //具名函式能在函式內被調用
  }
  functionC()
  console.log(functionC)
  console.log(functionD)  //functionD is not defined
  ```
  {% note no-icon %}
  ƒ functionD() {
    console.log(functionC, functionD)
  } ƒ functionD() {
    console.log(functionC, functionD)
  }
  {% endnote %}

  {% tabs 其他範例 %}
<!-- tab -->
```javascript
var num = 1 ;
var giveMeMoney = function giveMoreMoney(coin) {
  num += 1;
  console.log('執行 giveMeMoney', num, coin);
  return coin > 100 ? coin : giveMoreMoney(num*coin);
}
console.log(giveMeMoney(30))
```
{% note no-icon %}
執行 giveMeMoney 2 30
執行 giveMeMoney 3 60
執行 giveMeMoney 4 180
180
{% endnote %}
<!-- endtab -->

<!-- tab -->
```javascript
function callSomeOne(fn) {
  fn()
}
callSomeOne(function() {console.log('執行函式')})
```
{% note no-icon %}
執行函式
{% endnote %}
<!-- endtab -->
{% endtabs %}

- 透過 `new Function` 關鍵字建立函式
使用 `new Function` (<font color="red">注意 F 大寫</font>) 這個關鍵字來建立函式物件。
使用時將參數與函式的內容依序傳入 `Function`
```javascript
// 透過 new 來建立 Function "物件"
var square = new Function('number', 'return number * number');
```
>透過 `new Function` 所建立的函式物件，每次執行時都會進行解析「字串」(如 `'return number * number'` ) 的動作，運作效能較差，所以通常實務上也較少會這樣做。

- 箭頭函式 The arrow function expression (=>)
ES6新增的箭頭函式，使程式碼更為精簡。
將 `function` 改成 `=>` ，並移至 `()` 的後方。
```javascript
Arrow() => {
  console.log('箭頭函式');
};
Arrow
```

# 立即函式(IIFE)

**IIFE**
>IIFE (Immediately Invoked Function Expression) 是一個定義完馬上就執行的 JavaScript function，是一種常見的設計模式。
又可稱為 Self-Executing Anonymous Function。

IIFE包含兩部分
1. 使用 Grouping Operator `()` 包含的匿名函式。
2. 馬上執行 function 的 expression `()`，JavaScript 引擎看到它就會立刻轉譯該 function。
`(function(參數){ ... })()`

特性：
- 定義完立刻就執行
- 無法於函式外再次被執行
  ```javascript
  (function IFFE() {
    console.log('立即函式', IFFE)
  })();
  console.log(IFFE)
  ```
  {% note no-icon%}
  立即函式 ƒ IFFE() {
    console.log('立即函式', IFFE)
  }
  <font color='red'>{% label danger@IFFE is not defined%}</font>
  {% endnote%}
- 限制變數的作用域：{% label primary@function scope 內的變數在外面是無法存取的 %}。
  ```javascript
  (function () {
    var Name = 'IFFE';
    console.log(Name)   //IFFE
  })();
  console.log(Name)     //Name is not defined
  ```
- 可以傳遞參數
  ```javascript
  (function (para) {
    console.log('IFFE' + para)   //IFFE可以傳遞參數
  })('可以傳遞參數');
  // 把 IIFE 設定變數並儲存它的結果
  var result = (function (parameter) {
    return parameter
  })('return IFFE 結果')
  console.log(result)           //return IFFE 結果
  ```
- 須符合ASI規則：因立即函示不包含在ASI的規則內，故於2個函式間須插入 `;` ，否則會出現錯誤。
{% tabs 須符合ASI規則 %}
<!-- tab 錯誤 -->
```javascript
(function () {
})()
(function () {
})()
// (intermediate value)(...) is not a function
```
<!-- endtab -->

<!-- tab 正確 -->
```javascript
(function () {
})();
(function () {
})()
```
<!-- endtab -->
{% endtabs %}
- function間傳遞參數
{% tabs function間傳遞參數 %}
<!-- tab 建立新物件 -->
利用物件傳參考的特性，讓不同的function可以互相傳遞。
```javascript
var a = {};
(function (b) {
  b.parameter = '這是傳遞的變數'
})(a);
(function (c) {
  console.log(c.parameter)    //這是傳遞的變數
})(a)
```
<!-- endtab -->

<!-- tab 全域物件 -->
透過全域物件傳遞變數，常使用在大型框架上，如 [<font color=#41b883>Vue.js</font>](https://vuejs.org)，此方式可以確保框架可以正確的掛載於全域物件上。
```javascript
(function (global) {
  global.parameter = '透過window傳遞變數'
})(window);
(function () {
  console.log(parameter)    //透過window傳遞變數
})()
```
<!-- endtab -->
{% endtabs %}

其它形式
1. JSLint：符合 JSLint 的版本，須將 expression `()` 包進外層的 grouping operator `()` 內。
```javascript
(function () {
}());
```
2. Arrow function：ES6新增的箭頭函式，使程式碼更為精簡，但行為一致。
```javascript
(() => {
})();
```
3. Async function：ES7新增的 `async` ，目前主要為了 top level await 而使用。
```javascript
(async function () {
})();
//搭配箭頭函式
(async () => {
})();
```

# 參數
什麼是參數(parameter)?
參數其實就是我們會帶入函式的變數。
```javascript
var globalVariable = '全域變數';
var obj = {
  aFunction: function(para) {
    var localVariable = '區域變數';
    console.log(para, localVariable, arguments, this, globalVariable)
  }
}
obj.aFunction('一段描述', 2, 3);
```
{% note no-icon %}
***
一段描述 區域變數 >Arguments(3) *[*"一段描述", 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ*]* {aFunction: ƒ} 全域變數
***
1. {% label @一段描述 %}：外層所傳入的參數，雖然外層傳入3個參數，但是 `function` 只定義一個，而參數在給值的過程是由左至右的，所以只顯示一個。
2. {% label @區域變數 %}：function內所定義的區域變數。
3. {% label @Arguments(3) %}：arguments 其實就是 parameters 的意思，也就是說，arguments 會包含所有你放入 function 中的參數值。
  arguments回傳的值是斜體的 *[ ]* ，它並不是真的陣列而是一個 **類陣列**
4. {% label @this %}：執行函式時會自動帶入的變數。
  ><font size=3>補充：執行物件內函式的this與一般函式有所不同。</font>
5. {% label @全域變數 %}：來自於外層的變數，可參考**範圍鍊**章節。
{% endnote %}

## Hoisting與參數的關係
- function的變數在傳入前已經定義完成，故function內無法重複宣告變數。
- Hoistion並無會影響傳入的參數
  - 範例一：
```javascript
function callFunction(a) {
  console.log(a);           //傳入的參數
  var a;                    //無法重複宣告變數，無作用
  console.log(a);           //傳入的參數
  a = '修改的參數';
  console.log(a);           //修改的參數
};
callFunction('傳入的參數');
```
  - 範例二：
```javascript
function callFunction(a) {
  console.log(a);           //ƒ a() {}
  function a() {};
};
callFunction('傳入的參數');
```

## 參數與傳入值之間的關聯性
```javascript
function callMore (d, c, b, a) {
  console.log(d, c, b, a)
}
var a = 'a';
var b = 'b';
var c = 'c';
callMore(a, b, c)
```
{% note no-icon %}
***
a b c <font color="gray">undefined</font>
***
1. 參數的名稱是可以自定義的，與傳入的值並沒有關聯性。
1. 傳入的參數與 function 內的變數數量不一致時，多出的變數會顯示 <font color="gray">{% label @undefined %}</font>
  ><font size=3>註：因為當 JavaScript 在執行這個 function 的時候，它會先為我們的參數建立好記憶體位置，並且賦予它的值是 undefined 。(Javascript 中的 Hoisting 特性)</font>
1. 參數在給值的過程是由左至右的。
{% endnote %}

## callback function
```javascript
function helloWorld(para) {
  console.log(para);
}
function functionA(fn) {
  fn('HelloWorld');
}
functionA(helloWorld)
```
## arguments
arguments會包含所有你放入function中的參數值。
arguments回傳的值是斜體的 *[ ]* ，它並不是真的陣列而是一個 **類陣列**。
><font size=3>註：類陣列是指以數值索引的值所成的群集，它可能是串列但並非真正的陣列。可使用 `for` 但不能使用 `indexOf`、`concat`、`forEach` 等操作。</font>
```javascript
function callArg(a) {
  console.log(a, arguments)       //1 >Arguments(4) [1, 2, 3, "4", callee: ƒ, Symbol(Symbol.iterator): ƒ]
  //for 迴圈
  for(let i = 0; i <arguments.length; i++ ) {
    console.log(arguments[i])
  }
}
callArg(1, 2, 3, '4')
```

## 展開運算子spread(...)
JavaScript於ES6中另外提供了一個展開運算子(spread)，由3個 `.` 組成 「<font color="red">**...**</font>」。
可以把函數中許多的參數(arguments)或陣列中許多的元素(elements)展開(expand)成個別數值的速寫語法，簡單來說，就是把陣列裡面的值，拆解成一個一個。
```javascript
function newFunction(a, b, ...other) {
  console.log(other)        //["hello", "world"]
}
newFunction(1, 2, 'hello', 'world')
```

參考：[展開運算子spread MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

# 閉包 Closure
閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。

1. 運作原理：呼叫 Function 內的 Function。
2. 內層 Function 作用域變數只會存在內層。
3. 內層 Function 變數可以不被釋放，重複使用。

{% note info %}
大多數人會利用一個全域變數來儲存變數的資訊。但是，當程式碼開始變多了，過多的全域變數會造成不可預期的錯誤，像是變數名稱衝突、沒用到的變數無法回收等等的。
這時候改用閉包的做法就可以避免這些問題。
{% endnote%}

{% tabs Sixth unique name %}
<!-- tab 範例 1 @code -->
```javascript
function storeMoney() {
  var money = 1000;
  return function(price) {
    money = money + price
    return money
  }
}
var myMoney = storeMoney();
console.log(myMoney(1000))    //2000
var yourMoney = storeMoney();
console.log(yourMoney(10000))   //11000
```
<!-- endtab -->

<!-- tab  範例 2 @code -->
```javascript
function counter() {
  var count = 0;
  function innerCounter() {
    return count += 1;
  }
  return innerCounter;
}
var countFunc = counter();

console.log( countFunc() )    //1
console.log( countFunc() )    //2
console.log( countFunc() )    //3
```
<!-- endtab -->

<!-- tab  範例 3 @code -->
```javascript
function makeAdder(x) {
  return function(y) {
    return x + y
  }
}
var add5 = makeAdder(5)
var add10 = makeAdder(10)

console.log( add5(7) )  //12
console.log( add10(7) ) //17
```
<!-- endtab -->
{% endtabs %}

參考：[閉包 MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures)
參考：[閉包 重新認識 JavaScript](https://ithelp.ithome.com.tw/articles/10193009)
參考：[閉包 邁向 JavaScript 勇者之路](https://ithelp.ithome.com.tw/articles/10191515)